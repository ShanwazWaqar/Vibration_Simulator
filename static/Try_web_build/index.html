<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
    <!-- Add these two libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <title>4D Printing Simulator</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary: #BA0C2F;
            --primary-dark: #98041F;
            --primary-light: #F8E9EC;
            --accent: #F5BD1F;
            --dark: #131A2A;
            --darker: #0D1422;
            --light-gray: #F8FAFC;
            --border-radius: 6px;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Inter', sans-serif;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            position: fixed;
            background: var(--darker);
            touch-action: none;
        }

        #unity-container {
            width: 100%;
            height: 100%;
            position: absolute;
            background: var(--darker);
            overflow: hidden !important;
        }
        
        #header {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 60px;
            background: linear-gradient(90deg, #000000 0%, #1A1A1A 100%);
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 24px;
            border-bottom: 2px solid var(--primary);
            z-index: 10;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }
        
        #title {
            color: white;
            font-size: 22px;
            font-weight: 700;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            position: relative;
            padding-left: 16px;
            display: flex;
            align-items: center;
        }
        
        #title::before {
            content: '';
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 4px;
            height: 24px;
            background-color: var(--primary);
            border-radius: 2px;
        }
        
        #controls {
            display: flex;
            gap: 12px;
        }
        
        .control-button {
            background-color: rgba(255, 255, 255, 0.1);
            border: none;
            border-radius: 8px;
            color: white;
            padding: 8px 16px;
            font-size: 14px;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .control-button:hover {
            background-color: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }
        
        .control-button:active {
            transform: translateY(1px);
        }
        
        #pause-button {
            background-color: var(--primary);
            border: none;
        }
        
        #pause-button:hover {
            background-color: var(--primary-dark);
            box-shadow: 0 4px 8px rgba(186, 12, 47, 0.4);
        }
        
        #stop-button, #fullscreen-button {
            background-color: rgba(255, 255, 255, 0.1);
            border: none;
        }
        
        #stop-button:hover, #fullscreen-button:hover {
            background-color: rgba(255, 255, 255, 0.2);
        }
        
        .button-icon {
            width: 16px;
            height: 16px;
        }

        #unity-canvas-container {
          width: 100%;
          height: calc(100% - 60px);
          position: absolute;
          top: 60px;
          display: flex;
          justify-content: center;
          align-items: center;
          background: var(--darker) !important;
          overflow: hidden !important;
          margin: 0 !important;
          padding: 0 !important;
        }

        #unity-canvas {
          position: absolute;
          width: 100% !important;
          height: 100% !important;
          top: 0 !important;
          left: 0 !important;
          margin: 0 !important;
          padding: 0 !important;
          background: var(--darker) !important;
          object-fit: contain !important;
        }

        #unity-loading-bar {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            display: none;
            z-index: 100;
        }

        #unity-logo {
            width: 154px;
            height: 130px;
            background: url('/game/TemplateData/unity-logo-dark.png') no-repeat center;
            background-size: contain;
        }

        #unity-progress-bar-empty {
            width: 141px;
            height: 18px;
            margin: 10px 0;
            background: url('/game/TemplateData/progress-bar-empty-dark.png') no-repeat center;
            background-size: contain;
        }

        #unity-progress-bar-full {
            width: 0%;
            height: 18px;
            margin: 10px 0;
            background: url('/game/TemplateData/progress-bar-full-dark.png') no-repeat center;
            background-size: contain;
        }

        #unity-warning {
            position: absolute;
            left: 50%;
            top: 5%;
            transform: translateX(-50%);
            background: rgba(200, 0, 0, 0.8);
            padding: 10px;
            display: none;
            border-radius: 8px;
            color: white;
            font-family: 'Inter', sans-serif;
            font-size: 14px;
            max-width: 90%;
            text-align: center;
            z-index: 999;
        }

        #status-indicator {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 20px;
            padding: 8px 16px;
            display: flex;
            align-items: center;
            gap: 8px;
            z-index: 10;
            color: white;
            font-size: 14px;
        }
        
        .indicator-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: #10B981;
            display: inline-block;
        }
        
        /* Screenshot status indicator */
        #screenshot-status {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 20px;
            padding: 8px 16px;
            display: flex;
            align-items: center;
            gap: 8px;
            z-index: 10;
            color: white;
            font-size: 14px;
        }
        
        /* Download button */
        #download-button {
            position: absolute;
            top: 70px;
            right: 20px;
            z-index: 100;
            background-color: #3B82F6;
            display: none;
        }
        
        /* Responsive adjustments */
        @media screen and (max-width: 640px) {
            #title {
                font-size: 16px;
            }
            
            .control-button {
                padding: 6px 10px;
                font-size: 12px;
            }
            
            .button-icon {
                width: 14px;
                height: 14px;
            }
            
            #header {
                padding: 0 10px;
                height: 50px;
            }
            
            #unity-canvas-container {
                height: calc(100% - 50px);
                top: 50px;
            }
            
            #controls {
                gap: 5px;
            }
        }
    </style>
  </head>
  <body>
    <div id="unity-container" class="unity-desktop">
      <div id="header">
        <h1 id="title">4D Printing Simulator</h1>
        <div id="controls">
          <button id="pause-button" class="control-button">
            <svg class="button-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <rect x="6" y="4" width="4" height="16"></rect>
              <rect x="14" y="4" width="4" height="16"></rect>
            </svg>
            Pause
          </button>
          <button id="stop-button" class="control-button">
            <svg class="button-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <rect x="4" y="4" width="16" height="16" rx="2" ry="2"></rect>
            </svg>
            Stop
          </button>
          <button id="fullscreen-button" class="control-button">
            <svg class="button-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path>
            </svg>
            Fullscreen
          </button>
        </div>
      </div>
      
      <div id="unity-canvas-container">
        <canvas id="unity-canvas" tabindex="-1"></canvas>
      </div>
      
      <div id="unity-loading-bar">
        <div id="unity-logo"></div>
        <div id="unity-progress-bar-empty">
          <div id="unity-progress-bar-full"></div>
        </div>
      </div>
      
      <div id="unity-warning"></div>
      
      <div id="status-indicator">
        <span class="indicator-dot"></span>
        <span id="status-text">Initializing...</span>
      </div>
      
      <!-- Screenshot status indicator - Keep this as it's for Flask screenshots -->
      <div id="screenshot-status">
        <span class="indicator-dot" style="background-color: #3B82F6;"></span>
        <span id="screenshot-text">Screenshots: 0</span>
      </div>
      
      <!-- Download button (initially hidden) - Keep this as it's for Flask screenshots -->
      <button id="download-button" class="control-button" style="display: none;">
        <svg class="button-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
          <polyline points="7 10 12 15 17 10"></polyline>
          <line x1="12" y1="15" x2="12" y2="3"></line>
        </svg>
        Download Screenshots
      </button>
    </div>
    <script>
      var container = document.querySelector("#unity-container");
      var canvas = document.querySelector("#unity-canvas");
      var loadingBar = document.querySelector("#unity-loading-bar");
      var progressBarFull = document.querySelector("#unity-progress-bar-full");
      var warning = document.querySelector("#unity-warning");
      var statusIndicator = document.querySelector("#status-indicator");
      var statusText = document.querySelector("#status-text");
      var statusDot = document.querySelector(".indicator-dot");
      var gameInstance = null; // Will store Unity game instance
      var isIframe = window !== window.parent;
      var isPaused = false;
      let simulationParams = null;
      let activeScreenCaptureStream = null;
      
      // Screenshot variables for Flask-based screenshot system - KEEPING THIS
      var screenshotCount = 0;
      var screenshotText = document.getElementById('screenshot-text');
      var screenshotDot = document.querySelector('#screenshot-status .indicator-dot');
      var downloadButton = document.getElementById('download-button');
        
      function unityShowBanner(msg, type) {
        function updateBannerVisibility() {
          warning.style.display = warning.children.length ? 'block' : 'none';
        }
        var div = document.createElement('div');
        div.innerHTML = msg;
        warning.appendChild(div);
        if (type == 'error') div.style = 'background: rgba(200, 0, 0, 0.8); padding: 10px;';
        else {
          if (type == 'warning') div.style = 'background: rgba(200, 200, 0, 0.8); padding: 10px;';
          setTimeout(function() {
            warning.removeChild(div);
            updateBannerVisibility();
          }, 5000);
        }
        updateBannerVisibility();
      }

      async function requestScreenCapturePermission() {
  try {
    if (!navigator.mediaDevices || !navigator.mediaDevices.getDisplayMedia) {
      console.warn("Screen Capture API not available in this browser");
      return false;
    }
    
    // Request screen sharing permission from the user
    const stream = await navigator.mediaDevices.getDisplayMedia({
      video: { 
        cursor: "never",
        displaySurface: "browser" // Try to capture just the browser window
      }
    });
    
    // Store the stream globally
    activeScreenCaptureStream = stream;
    
    // Listen for when the stream ends (user stops sharing)
    const tracks = stream.getVideoTracks();
    if (tracks.length > 0) {
      tracks[0].addEventListener('ended', () => {
        console.log('Screen sharing ended by user');
        activeScreenCaptureStream = null;
      });
    }
    
    return true;
  } catch (error) {
    console.error("Error requesting screen capture permission:", error);
    return false;
  }
}

async function captureScreenshotFromStream() {
  if (!activeScreenCaptureStream) {
    console.warn("No active screen capture stream available");
    return null;
  }
  
  try {
    // Get the video track
    const videoTrack = activeScreenCaptureStream.getVideoTracks()[0];
    if (!videoTrack) {
      console.warn("No video track available in the stream");
      return null;
    }
    
    // Create a video element to capture the current frame
    const video = document.createElement('video');
    video.srcObject = activeScreenCaptureStream;
    
    // Wait for video to be ready
    await new Promise(resolve => {
      video.onloadedmetadata = resolve;
      setTimeout(resolve, 500); // Fallback timeout
    });
    
    // Start playing to get the current frame
    video.play();
    
    // Wait for the video to start playing
    await new Promise(resolve => {
      video.onplaying = resolve;
      setTimeout(resolve, 500); // Fallback if onplaying doesn't fire
    });
    
    // Create a canvas to draw the video frame
    const canvas = document.createElement('canvas');
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    
    // Draw the video frame to the canvas
    const ctx = canvas.getContext('2d');
    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
    
    // No need to stop the track since we're keeping it active
    video.pause();
    video.srcObject = null;
    
    // Convert the canvas to a data URL
    return canvas.toDataURL('image/png');
  } catch (error) {
    console.error("Error capturing from stream:", error);
    return null;
  }
}

function addScreenCaptureUI() {
  // Only add the elements if they don't exist
  if (!document.getElementById('screen-capture-ui')) {
    // Create container
    const container = document.createElement('div');
    container.id = 'screen-capture-ui';
    container.style.position = 'absolute';
    container.style.top = '70px';
    container.style.left = '20px';
    container.style.zIndex = '100';
    container.style.display = 'flex';
    container.style.flexDirection = 'column';
    container.style.gap = '10px';
    
    // Create permission button
    const permissionButton = document.createElement('button');
    permissionButton.id = 'request-permission-button';
    permissionButton.className = 'control-button';
    permissionButton.style.backgroundColor = '#3B82F6'; // Blue
    permissionButton.innerHTML = `
      <svg class="button-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
        <circle cx="8.5" cy="8.5" r="1.5"></circle>
        <polyline points="21 15 16 10 5 21"></polyline>
      </svg>
      Enable Screen Capture
    `;
    
    // Create screenshot button (initially hidden)
    const screenshotButton = document.createElement('button');
    screenshotButton.id = 'take-screenshot-button';
    screenshotButton.className = 'control-button';
    screenshotButton.style.backgroundColor = '#10B981'; // Green
    screenshotButton.style.display = 'none'; // Hide initially
    screenshotButton.innerHTML = `
      <svg class="button-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"></path>
        <circle cx="12" cy="13" r="4"></circle>
      </svg>
      Take Screenshot
    `;
    
    // Add permission button event
    permissionButton.addEventListener('click', async function() {
      permissionButton.innerHTML = `
        <svg class="button-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <circle cx="12" cy="12" r="10"></circle>
          <polyline points="12 6 12 12 16 14"></polyline>
        </svg>
        Requesting...
      `;
      
      const granted = await requestScreenCapturePermission();
      
      if (granted) {
        // Hide permission button, show screenshot button
        permissionButton.style.display = 'none';
        screenshotButton.style.display = 'flex';
        
        // Also start automatic screenshots
        startAutomaticScreenshots();
      } else {
        permissionButton.innerHTML = `
          <svg class="button-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
            <circle cx="8.5" cy="8.5" r="1.5"></circle>
            <polyline points="21 15 16 10 5 21"></polyline>
          </svg>
          Enable Screen Capture
        `;
      }
    });
    
    // Add screenshot button event
    screenshotButton.addEventListener('click', async function() {
      screenshotButton.innerHTML = `
        <svg class="button-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <circle cx="12" cy="12" r="10"></circle>
          <polyline points="12 6 12 12 16 14"></polyline>
        </svg>
        Capturing...
      `;
      
      // Take the screenshot using the active stream
      await takeScreenshot();
      
      // Reset button
      screenshotButton.innerHTML = `
        <svg class="button-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"></path>
          <circle cx="12" cy="13" r="4"></circle>
        </svg>
        Take Screenshot
      `;
    });
    
    // Add buttons to container
    container.appendChild(permissionButton);
    container.appendChild(screenshotButton);
    
    // Add container to body
    document.body.appendChild(container);
  }
}

// Function to start automatic screenshots
function startAutomaticScreenshots() {
  // Set up interval for automatic screenshots
  if (window.screenshotInterval) {
    clearInterval(window.screenshotInterval);
  }
  
  // Take first screenshot right away
  takeScreenshot();
  
  // Set up interval for more screenshots
  window.screenshotInterval = setInterval(takeScreenshot, 60000); // Every 60 seconds
}

      function updateCanvasSize() {
        var windowWidth = window.innerWidth;
        var windowHeight = window.innerHeight - document.getElementById('header').offsetHeight;
        
        // Set canvas to fill the entire available area
        canvas.style.width = "100%";
        canvas.style.height = "100%";
        canvas.style.top = "0";
        canvas.style.left = "0";
        
        // Remove any additional padding or margins
        document.getElementById('unity-canvas-container').style.padding = "0";
        document.getElementById('unity-canvas-container').style.margin = "0";
        
        // Ensure correct background color
        canvas.style.backgroundColor = "#0D1422";
        document.getElementById('unity-canvas-container').style.backgroundColor = "#0D1422";
      }
      
      function updateStatus(status) {
        if (!statusText || !statusDot) return;
        
        statusText.textContent = status;
        
        // Update dot color based on status
        switch (status) {
          case "Running":
            statusDot.style.backgroundColor = "#10B981"; // Green
            break;
          case "Paused":
            statusDot.style.backgroundColor = "#F59E0B"; // Amber
            break;
          case "Stopped":
            statusDot.style.backgroundColor = "#EF4444"; // Red
            break;
          case "Initializing...":
            statusDot.style.backgroundColor = "#3B82F6"; // Blue
            break;
          default:
            statusDot.style.backgroundColor = "#6B7280"; // Gray
        }
      }
      
      // Function to update screenshot count display - KEEPING THIS for Flask screenshots
      function updateScreenshotStatus() {
        const screenshotText = document.getElementById('screenshot-text');
        if (screenshotText) {
          screenshotText.textContent = `Screenshots: ${screenshotCount}`;
        }
      }

      var buildUrl = "/game/Build";
      var loaderUrl = buildUrl + "/Try_web_build.loader.js";
      var config = {
        dataUrl: buildUrl + "/Try_web_build.data",
        frameworkUrl: buildUrl + "/Try_web_build.framework.js",
        codeUrl: buildUrl + "/Try_web_build.wasm",
        streamingAssetsUrl: "/game/StreamingAssets",
        companyName: "DefaultCompany",
        productName: "VibrationPlatformSimulator",
        productVersion: "0.1",
        showBanner: unityShowBanner,
      };

      // Device detection and optimization
      if (/iPhone|iPad|iPod|Android|webOS|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
        // Mobile device optimizations
        container.className = "unity-mobile";
        
        // Optimize for mobile performance
        config.devicePixelRatio = Math.min(window.devicePixelRatio, 2);
        
        // Prevent unwanted touch behaviors
        document.addEventListener('touchmove', function(e) {
            e.preventDefault();
        }, { passive: false });
      }

      // Update status to initializing
      updateStatus("Initializing...");
      
      loadingBar.style.display = "block";

      var script = document.createElement("script");
      script.src = loaderUrl;
      script.onload = () => {
        createUnityInstance(canvas, config, (progress) => {
          progressBarFull.style.width = 100 * progress + "%";
        }).then((unityInstance) => {
          gameInstance = unityInstance; // Store reference for later use
          loadingBar.style.display = "none";
          
          // Wait a bit for Unity to initialize fully
          setTimeout(() => {
            console.log("Unity WebGL instance loaded successfully");
            
            // Find the correct GameManager GameObject
            const gameManagerName = findGameManager(unityInstance);
            console.log("Using GameObject name:", gameManagerName);
            
            // Set up control buttons with the correct GameObject name
            setupControlButtons(unityInstance, gameManagerName);
            
            // Auto-start the simulation by fetching parameters
            fetchSimulationParameters(unityInstance, gameManagerName);
            
            // Start Flask screenshot capture - KEEPING THIS
            startScreenshotCapture();
            
            // Add a debug message to check if communication is working
            try {
              unityInstance.SendMessage(gameManagerName, 'CaptureCurrentState');
              console.log("Test message sent to GameManager");
              updateStatus("Running");
            } catch (error) {
              console.error("Error communicating with Unity:", error);
              updateStatus("Error");
            }
          }, 1000); // Wait 1 second for Unity to initialize fully
          
        }).catch((message) => {
          console.error("Error loading Unity application:", message);
          unityShowBanner("Failed to load simulation: " + message, "error");
          updateStatus("Error");
        });
      };

      document.body.appendChild(script);
      
      // Function to find the correct GameManager object
      function findGameManager(unityInstance) {
        // Try different possible GameObject names
        const possibleNames = [
          'GameManger',            // Common typo/variant (without 'a')
          'GameManager',           // Direct name
          'MyGameNamespace.GameManger', // With namespace (without 'a')
          'MyGameNamespace.GameManager', // With namespace
          '/GameManger',           // Root path (without 'a')
          '/GameManager',          // Root path
          'GameController',        // Alternative name
          'SimulationManager',     // Alternative name
          'Game Manager'           // With space
        ];
        
        // Also try to find by tag
        try {
          unityInstance.SendMessage('GameObject', 'FindGameObjectWithTag', 'GameManager');
          console.log("Attempting to find by tag");
        } catch (e) {
          console.log("FindGameObjectWithTag not supported");
        }
        
        // Log all root GameObjects to console for debugging
        try {
          console.log("Checking for available Unity GameObjects...");
          unityInstance.SendMessage('GameObject', 'LogAllRootObjects');
        } catch (e) {
          console.log("Cannot log root objects");
        }
        
        // Test each possible name
        for (const name of possibleNames) {
          try {
            console.log(`Testing GameObject name: ${name}`);
            unityInstance.SendMessage(name, 'TestMessageReceived');
            console.log(`Found valid GameObject: ${name}`);
            return name;
          } catch (e) {
            console.log(`Cannot find GameObject: ${name}`);
          }
        }
        
        // Default fallback to the name you mentioned
        console.log("Using GameManger (without 'a') as fallback");
        return 'GameManger';
      }
      
      // Set up control buttons to communicate with Unity
      function setupControlButtons(unityInstance, gameManagerName) {
        // Pause/Resume button
        const pauseButton = document.getElementById('pause-button');
        pauseButton.addEventListener('click', function() {
          if (unityInstance) {
            try {
              // Directly set simulation state variables
              if (!isPaused) {
                // Pause the simulation
                unityInstance.SendMessage(gameManagerName, 'pauseF', 'true');
                unityInstance.SendMessage(gameManagerName, 'prevStateF', 'true');
                unityInstance.SendMessage(gameManagerName, 'timesStateSetF', 'true');
                updateStatus("Paused");
              } else {
                // Resume the simulation
                unityInstance.SendMessage(gameManagerName, 'pauseF', 'false');
                unityInstance.SendMessage(gameManagerName, 'prevStateF', 'false');
                unityInstance.SendMessage(gameManagerName, 'timesStateSetF', 'true');
                updateStatus("Running");
              }
              
              // Also call the handler for UI updates
              unityInstance.SendMessage(gameManagerName, 'HandlePauseButton');
              
              // Update local state
              isPaused = !isPaused;
              pauseButton.innerHTML = isPaused ? 
                '<svg class="button-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg> Resume' : 
                '<svg class="button-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg> Pause';
              
              console.log(isPaused ? 'Simulation paused' : 'Simulation resumed');
            } catch (error) {
              console.error("Error pausing simulation:", error);
            }
          }
        });
        
        // Stop button
        const stopButton = document.getElementById('stop-button');
        stopButton.addEventListener('click', function() {
          if (unityInstance) {
            try {
              // Set simulation state variables
              unityInstance.SendMessage(gameManagerName, 'pauseF', 'true');
              unityInstance.SendMessage(gameManagerName, 'prevStateF', 'true');
              unityInstance.SendMessage(gameManagerName, 'timesStateSetF', 'true');
              unityInstance.SendMessage(gameManagerName, 'simulationRunning', 'false');
              
              // Call the handler for UI updates
              unityInstance.SendMessage(gameManagerName, 'HandleStopButton');
              
              // Stop screenshot capture and prepare download - KEEPING THIS for Flask
              stopScreenshotCapture();
              
              // Update local state
              isPaused = true;
              pauseButton.innerHTML = '<svg class="button-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg> Resume';
              pauseButton.disabled = true; // Disable pause button when stopped
              updateStatus("Stopped");
              console.log('Simulation stopped');
            } catch (error) {
              console.error("Error stopping simulation:", error);
            }
          }
        });
        
        // Fullscreen button
        const fullscreenButton = document.getElementById('fullscreen-button');
        fullscreenButton.addEventListener('click', function() {
          if (unityInstance) {
            try {
              unityInstance.SendMessage(gameManagerName, 'HandleFullscreenButton');
              console.log('Fullscreen toggled');
              
              // Also use browser fullscreen API as fallback
              toggleFullscreen();
            } catch (error) {
              console.error("Error toggling fullscreen:", error);
              
              // Use browser fullscreen as fallback
              toggleFullscreen();
            }
          } else {
            // Use browser fullscreen if Unity isn't loaded
            toggleFullscreen();
          }
        });
        
        // Download button - KEEPING THIS for Flask screenshots
        const downloadBtn = document.getElementById('download-button');
        downloadBtn.addEventListener('click', function() {
          createAndDownloadZip();
        });
      }
      
      // Browser fullscreen API handling
      function toggleFullscreen() {
        if (!document.fullscreenElement) {
          if (document.documentElement.requestFullscreen) {
            document.documentElement.requestFullscreen();
          } else if (document.documentElement.webkitRequestFullscreen) {
            document.documentElement.webkitRequestFullscreen();
          } else if (document.documentElement.msRequestFullscreen) {
            document.documentElement.msRequestFullscreen();
          }
        } else {
          if (document.exitFullscreen) {
            document.exitFullscreen();
          } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
          } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
          }
        }
      }
      
      // Function to fetch simulation parameters from server
      function fetchSimulationParameters(unityInstance, gameManagerName) {
  fetch('/get-data')
    .then(response => response.json())
    .then(data => {
      console.log("Received simulation parameters:", data);
      // Store parameters globally for screenshot generation
      simulationParams = data;
      
      if (unityInstance) {
        try {
          // Set individual parameters directly based on the C# GameManager fields
          // This ensures proper value types (int vs float) are set correctly
          unityInstance.SendMessage(gameManagerName, 'Spring_const', data.SC.toString());
          unityInstance.SendMessage(gameManagerName, 'bond_break_F', data.BF.toString());
          unityInstance.SendMessage(gameManagerName, 'Amplitude_X', data.AmpX.toString());
          unityInstance.SendMessage(gameManagerName, 'Amplitude_Y', data.AmpY.toString());
          unityInstance.SendMessage(gameManagerName, 'Amplitude_Z', data.AmpZ.toString());
          unityInstance.SendMessage(gameManagerName, 'Frequency_X', data.freqX.toString());
          unityInstance.SendMessage(gameManagerName, 'Frequency_Y', data.freqY.toString());
          unityInstance.SendMessage(gameManagerName, 'Frequency_Z', data.freqZ.toString());
          unityInstance.SendMessage(gameManagerName, 'sphere_count', data.sphereCount.toString());
          unityInstance.SendMessage(gameManagerName, 'rectangle_Count', data.rectangleCount.toString());
          unityInstance.SendMessage(gameManagerName, 'quartersphere_Count', data.quartersphereCount.toString());
          unityInstance.SendMessage(gameManagerName, 'Airfoil_count', (data.airfoilCount || 0).toString());
          unityInstance.SendMessage(gameManagerName, 'halfsphere_Count', (data.halfsphereCount || 0).toString());
          unityInstance.SendMessage(gameManagerName, 'pyramid_Count', (data.pyramidCount || 0).toString());
          
          // Set readyForControlParameters flag
          unityInstance.SendMessage(gameManagerName, 'readyForControlParameters', 'true');
          
          // Set simulation running flag
          setTimeout(() => {
            // This is important - need to activate simulation controller
            unityInstance.SendMessage(gameManagerName, 'simulationRunning', 'true');
            
            // Make sure simulation is actually running
            // These three flags need to be set in this specific order to work correctly
            // First set the pause state
            unityInstance.SendMessage(gameManagerName, 'pauseF', 'false');
            // Then set the previous state (which is compared in Update())
            unityInstance.SendMessage(gameManagerName, 'prevStateF', 'false');
            // Finally set the flag that triggers the update in Update()
            unityInstance.SendMessage(gameManagerName, 'timesStateSetF', 'true');
            
            console.log("Simulation parameters set and simulation started");
            updateStatus("Running");
          }, 1000);
        } catch (error) {
          console.error("Error sending parameters to Unity:", error);
          unityShowBanner("Error configuring simulation: " + error, "error");
          updateStatus("Error");
        }
      }
    })
    .catch(error => {
      console.error("Error fetching simulation parameters:", error);
      unityShowBanner("Failed to fetch simulation data: " + error, "error");
      updateStatus("Error");
    });
}

function createSimulationVisual() {
  // If no simulation parameters are available, return null
  if (!simulationParams) {
    console.error("No simulation parameters available for visual creation");
    return null;
  }
  
  // Create canvas for the visual
  const canvas = document.createElement('canvas');
  const width = 800;
  const height = 600;
  canvas.width = width;
  canvas.height = height;
  const ctx = canvas.getContext('2d');
  
  // Fill background
  ctx.fillStyle = "#0D1422"; // Dark background matching Unity
  ctx.fillRect(0, 0, width, height);
  
  // Add title
  ctx.fillStyle = "#FFFFFF";
  ctx.font = "bold 28px Inter";
  ctx.textAlign = "center";
  ctx.fillText("4D Printing Simulation", width/2, 50);
  
  // Add timestamp
  const timestamp = new Date().toLocaleString();
  ctx.font = "16px Inter";
  ctx.fillText(timestamp, width/2, 80);
  
  // Draw parameters section
  ctx.font = "bold 20px Inter";
  ctx.textAlign = "left";
  ctx.fillText("Simulation Parameters", 50, 130);
  
  // Add parameter values
  ctx.font = "18px Inter";
  let y = 170;
  const lineHeight = 32;
  
  // Core parameters
  ctx.fillText(`Spring Constant: ${simulationParams.SC}`, 70, y); y += lineHeight;
  ctx.fillText(`Bond Break Force: ${simulationParams.BF}`, 70, y); y += lineHeight;
  
  // Amplitudes
  ctx.fillText("Amplitude:", 70, y); y += lineHeight;
  ctx.fillText(`X: ${simulationParams.AmpX}   Y: ${simulationParams.AmpY}   Z: ${simulationParams.AmpZ}`, 100, y); y += lineHeight;
  
  // Frequencies
  ctx.fillText("Frequency:", 70, y); y += lineHeight;
  ctx.fillText(`X: ${simulationParams.freqX}   Y: ${simulationParams.freqY}   Z: ${simulationParams.freqZ}`, 100, y); y += lineHeight;
  
  // Draw shapes section
  y += 20;
  ctx.font = "bold 20px Inter";
  ctx.fillText("Shapes", 50, y); y += lineHeight;
  
  // Add shape counts
  ctx.font = "18px Inter";
  const shapesPresent = [];
  
  if (parseInt(simulationParams.sphereCount) > 0) {
    shapesPresent.push(`Spheres: ${simulationParams.sphereCount}`);
  }
  
  if (parseInt(simulationParams.rectangleCount) > 0) {
    shapesPresent.push(`Rectangles: ${simulationParams.rectangleCount}`);
  }
  
  if (parseInt(simulationParams.quartersphereCount) > 0) {
    shapesPresent.push(`Quarter Spheres: ${simulationParams.quartersphereCount}`);
  }
  
  if (shapesPresent.length === 0) {
    ctx.fillText("No shapes selected", 70, y);
  } else {
    shapesPresent.forEach(shape => {
      ctx.fillText(shape, 70, y);
      y += lineHeight;
    });
  }
  
  // Draw simulation visualization
  y = Math.max(y + 40, 350); // Make sure we have enough space
  
  ctx.fillStyle = "#1A2035";
  ctx.fillRect(width/2 - 250, y, 500, 200);
  ctx.strokeStyle = "#BA0C2F";
  ctx.lineWidth = 2;
  ctx.strokeRect(width/2 - 250, y, 500, 200);
  
  // Draw a platform representation
  ctx.fillStyle = "#3B82F6";
  ctx.fillRect(width/2 - 200, y + 150, 400, 10);
  
  // Draw shapes based on parameters
  drawShapesVisualization(ctx, width/2, y + 100);
  
  // Add screenshot number
  ctx.fillStyle = "#FFFFFF";
  ctx.font = "14px Inter";
  ctx.textAlign = "right";
  ctx.fillText(`Screenshot #${screenshotCount}`, width - 30, height - 20);
  
  // Return the canvas as a data URL
  return canvas.toDataURL('image/png');
}

// Draw shapes based on the simulation parameters
function drawShapesVisualization(ctx, centerX, centerY) {
  const shapesData = [];
  
  // Add spheres
  const sphereCount = parseInt(simulationParams.sphereCount) || 0;
  for (let i = 0; i < sphereCount; i++) {
    shapesData.push({ 
      type: 'sphere', 
      x: centerX - 150 + (i * 50) % 300, 
      y: centerY - 25 + Math.floor(i / 6) * 50 
    });
  }
  
  // Add rectangles
  const rectCount = parseInt(simulationParams.rectangleCount) || 0;
  for (let i = 0; i < rectCount; i++) {
    shapesData.push({ 
      type: 'rectangle', 
      x: centerX - 140 + (i * 60) % 280, 
      y: centerY - 15 + Math.floor(i / 5) * 30 
    });
  }
  
  // Add quarter spheres
  const quarterCount = parseInt(simulationParams.quartersphereCount) || 0;
  for (let i = 0; i < quarterCount; i++) {
    shapesData.push({ 
      type: 'quarter', 
      x: centerX - 130 + (i * 55) % 260, 
      y: centerY - 20 + Math.floor(i / 5) * 40 
    });
  }
  
  // Draw all shapes
  shapesData.forEach(shape => {
    if (shape.type === 'sphere') {
      ctx.fillStyle = "#BA0C2F"; // Primary color
      ctx.beginPath();
      ctx.arc(shape.x, shape.y, 12, 0, Math.PI * 2);
      ctx.fill();
    } else if (shape.type === 'rectangle') {
      ctx.fillStyle = "#F5BD1F"; // Accent color
      ctx.fillRect(shape.x - 8, shape.y - 15, 16, 30);
    } else if (shape.type === 'quarter') {
      ctx.fillStyle = "#10B981"; // Green color
      ctx.beginPath();
      ctx.arc(shape.x, shape.y, 15, Math.PI, Math.PI * 1.5);
      ctx.lineTo(shape.x, shape.y);
      ctx.closePath();
      ctx.fill();
    }
  });
  
  // Add amplitude waves representation
  const ampY = parseFloat(simulationParams.AmpY) || 0;
  if (ampY > 0) {
    ctx.strokeStyle = "rgba(255, 255, 255, 0.5)";
    ctx.lineWidth = 1;
    ctx.beginPath();
    
    const waveWidth = 300;
    const waveHeight = Math.min(ampY * 10, 30);
    const freqY = parseFloat(simulationParams.freqY) || 1;
    
    ctx.moveTo(centerX - waveWidth/2, centerY + 60);
    
    for (let x = -waveWidth/2; x <= waveWidth/2; x += 5) {
      const y = Math.sin((x / waveWidth) * Math.PI * 2 * freqY) * waveHeight;
      ctx.lineTo(centerX + x, centerY + 60 + y);
    }
    
    ctx.stroke();
  }
}

      
      // Start screenshot capture process
      async function startScreenshotCapture() {
  console.log('Preparing to start screenshot capture...');
  
  try {
    // Add the screen capture UI buttons
    addScreenCaptureUI();
    
    // Load html2canvas for fallback
    try {
      await loadHTML2Canvas();
      console.log("html2canvas loaded for fallback");
    } catch (e) {
      console.log("html2canvas not available");
    }
    
    // Initialize the database
    await initDatabase();
    
    // Clear any existing screenshots
    await clearScreenshots();
    
    screenshotCount = 0;
    updateScreenshotStatus();
    
    // No automatic screenshots until permission is granted
    console.log("Waiting for user to enable screen capture...");
  } catch (error) {
    console.error('Error initializing screenshot capture:', error);
  }
}
      
      // Stop screenshot capture and prepare download
async function stopScreenshotCapture() {
  // Clear screenshot interval
  if (window.screenshotInterval) {
    clearInterval(window.screenshotInterval);
    window.screenshotInterval = null;
  }
  
  console.log('Screenshot capture stopped');
  
  // Update UI
  const screenshotDot = document.querySelector('#screenshot-status .indicator-dot');
  if (screenshotDot) {
    screenshotDot.style.backgroundColor = "#EF4444"; // Red
  }
  
  // Show download button
  const downloadBtn = document.getElementById('download-button');
  if (downloadBtn) {
    downloadBtn.style.display = 'flex';
  }
}

      // Handle resize and orientation changes
      window.addEventListener('resize', updateCanvasSize);
      window.addEventListener('orientationchange', function() {
        setTimeout(updateCanvasSize, 100);
      });

      // Initial size setup
      updateCanvasSize();

      // Handle visibility changes (pause when tab is not visible)
      document.addEventListener('visibilitychange', function() {
        if (gameInstance) {
          if (document.hidden) {
            try {
              gameInstance.SendMessage('GameManger', 'OnApplicationPause', 'true');
            } catch (e) { 
              console.log("Could not pause Unity game:", e);
            }
          } else {
            updateCanvasSize();
            try {
              gameInstance.SendMessage('GameManger', 'OnApplicationPause', 'false');
            } catch (e) {
              console.log("Could not resume Unity game:", e);
            }
          }
        }
      });

      // Prevent pinch zoom on mobile
      document.addEventListener('gesturestart', function(e) {
        e.preventDefault();
      });

      //client side download feature
      // Initialize IndexedDB
let db;
const DB_NAME = 'screenshotDB';
const STORE_NAME = 'screenshots';

function initDatabase() {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open(DB_NAME, 1);
    
    request.onerror = (event) => {
      console.error("IndexedDB error:", event.target.error);
      reject(event.target.error);
    };
    
    request.onupgradeneeded = (event) => {
      db = event.target.result;
      if (!db.objectStoreNames.contains(STORE_NAME)) {
        db.createObjectStore(STORE_NAME, { keyPath: 'id' });
        console.log("Created screenshots store");
      }
    };
    
    request.onsuccess = (event) => {
      db = event.target.result;
      console.log("IndexedDB initialized successfully");
      resolve(db);
    };
  });
}

// Save screenshot to IndexedDB
function saveScreenshot(screenshotData, id) {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction([STORE_NAME], 'readwrite');
    const store = transaction.objectStore(STORE_NAME);
    
    const screenshot = {
      id: id,
      data: screenshotData,
      timestamp: new Date().toISOString()
    };
    
    const request = store.put(screenshot);
    
    request.onsuccess = () => {
      resolve(id);
    };
    
    request.onerror = (event) => {
      console.error("Error saving screenshot:", event.target.error);
      reject(event.target.error);
    };
  });
}

// Capture screenshot from Unity canvas with proper handling for WebGL
function captureUnityCanvas() {
  const canvas = document.getElementById('unity-canvas');
  if (!canvas) {
    console.error("Unity canvas not found");
    return null;
  }
  
  try {
    // Get canvas dimensions for logging
    const dimensions = {
      width: canvas.width || canvas.clientWidth,
      height: canvas.height || canvas.clientHeight,
      style: canvas.style.width + " x " + canvas.style.height
    };
    console.log("Canvas dimensions:", dimensions);
    
    // Create a temporary canvas with the same dimensions
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = dimensions.width;
    tempCanvas.height = dimensions.height;
    
    // WebGL canvases use a different context that can't be directly copied
    // We need to try a few approaches to get the content
    
    // Approach 1: Use HTML2Canvas library if available
    if (window.html2canvas) {
      console.log("Using html2canvas for capture");
      return new Promise((resolve) => {
        html2canvas(canvas, {
          useCORS: true,
          allowTaint: true,
          backgroundColor: "#0D1422",
          logging: true
        }).then(renderedCanvas => {
          resolve(renderedCanvas.toDataURL('image/png'));
        }).catch(err => {
          console.error("html2canvas failed:", err);
          // Fall back to rendering the parameters only
          resolve(createSimulationVisual());
        });
      });
    }
    
    // Approach 2: Try direct drawing (likely to give black screen due to security)
    const ctx = tempCanvas.getContext('2d');
    ctx.fillStyle = "#0D1422";
    ctx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
    
    try {
      // This may throw a security error with WebGL content
      ctx.drawImage(canvas, 0, 0, tempCanvas.width, tempCanvas.height);
      
      // Check if we got a blank image or just the background
      const imageData = ctx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
      const pixels = imageData.data;
      
      // Check a sample of pixels to see if we got anything besides the background
      let nonBackgroundPixelsFound = false;
      const backgroundRGB = [13, 20, 34]; // #0D1422 in RGB
      
      for (let i = 0; i < pixels.length; i += 4 * 100) { // Check every 100th pixel
        if (
          Math.abs(pixels[i] - backgroundRGB[0]) > 5 ||
          Math.abs(pixels[i + 1] - backgroundRGB[1]) > 5 ||
          Math.abs(pixels[i + 2] - backgroundRGB[2]) > 5
        ) {
          nonBackgroundPixelsFound = true;
          break;
        }
      }
      
      if (!nonBackgroundPixelsFound) {
        console.log("Capture appears to be blank or just background, will use simulation visual");
        return createSimulationVisual();
      }
      
      console.log("Direct canvas capture appears successful");
      return tempCanvas.toDataURL('image/png');
    } catch (drawError) {
      console.error("Direct canvas drawing failed:", drawError);
      return createSimulationVisual();
    }
  } catch (error) {
    console.error("Error capturing screenshot:", error);
    return createSimulationVisual();
  }
}

function captureWithCORS() {
  const canvas = document.getElementById('unity-canvas');
  if (!canvas) return null;
  
  try {
    // Create a temporary image element
    const img = new Image();
    img.crossOrigin = "anonymous"; // Try to avoid CORS issues
    
    // Convert the canvas to a data URL and use it as the image source
    // This might work if the canvas doesn't have tainted content
    img.src = canvas.toDataURL('image/png');
    
    // Create a new canvas to draw the image
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = canvas.width || canvas.clientWidth;
    tempCanvas.height = canvas.height || canvas.clientHeight;
    const ctx = tempCanvas.getContext('2d');
    
    // Wait for the image to load before drawing it
    return new Promise((resolve) => {
      img.onload = function() {
        ctx.drawImage(img, 0, 0);
        resolve(tempCanvas.toDataURL('image/png'));
      };
      
      img.onerror = function() {
        console.error("Failed to load canvas as image");
        resolve(createSimulationVisual());
      };
      
      // Set a timeout in case the image doesn't load
      setTimeout(() => {
        if (!img.complete) {
          console.error("Image load timed out");
          resolve(createSimulationVisual());
        }
      }, 1000);
    });
  } catch (error) {
    console.error("Error with CORS capture:", error);
    return createSimulationVisual();
  }
}

// Get all screenshots from IndexedDB
function getAllScreenshots() {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction([STORE_NAME], 'readonly');
    const store = transaction.objectStore(STORE_NAME);
    const request = store.getAll();
    
    request.onsuccess = () => {
      resolve(request.result);
    };
    
    request.onerror = (event) => {
      console.error("Error getting screenshots:", event.target.error);
      reject(event.target.error);
    };
  });
}

// Clear all screenshots from the database
function clearScreenshots() {
  return new Promise((resolve, reject) => {
    if (!db) {
      resolve(); // DB not initialized yet, nothing to clear
      return;
    }
    
    const transaction = db.transaction([STORE_NAME], 'readwrite');
    const store = transaction.objectStore(STORE_NAME);
    const request = store.clear();
    
    request.onsuccess = () => {
      console.log("All screenshots cleared");
      resolve();
    };
    
    request.onerror = (event) => {
      console.error("Error clearing screenshots:", event.target.error);
      reject(event.target.error);
    };
  });
}

// Take a single screenshot and save it
async function takeScreenshot() {
  try {
    let screenshotData = null;
    
    // Try to use the active screen capture stream if available
    if (activeScreenCaptureStream) {
      screenshotData = await captureScreenshotFromStream();
    }
    
    // If stream capture failed, fall back to html2canvas
    if (!screenshotData && window.html2canvas) {
      console.log("Using html2canvas fallback");
      const container = document.body;
      const renderedCanvas = await html2canvas(container, {
        useCORS: true,
        allowTaint: true,
        backgroundColor: "#0D1422",
        scale: window.devicePixelRatio || 1,
        logging: true
      });
      
      screenshotData = renderedCanvas.toDataURL('image/png');
    }
    
    // If all direct capture methods failed, fall back to parameters visualization
    if (!screenshotData) {
      console.log("Using parameter visualization fallback");
      screenshotData = createSimulationVisual();
    }
    
    // Save the screenshot
    if (screenshotData) {
      screenshotCount++;
      const id = `screenshot_${new Date().toISOString().replace(/[:.]/g, '')}_${screenshotCount}`;
      await saveScreenshot(screenshotData, id);
      console.log(`Screenshot ${screenshotCount} captured`);
      updateScreenshotStatus();
      return true;
    } else {
      console.error("Failed to capture screenshot by any method");
      return false;
    }
  } catch (error) {
    console.error('Error taking screenshot:', error);
    return false;
  }
}

function captureVisible() {
  return new Promise((resolve) => {
    // First try using the browser's screenshot API if available
    if (navigator.mediaDevices && navigator.mediaDevices.getDisplayMedia) {
      navigator.mediaDevices.getDisplayMedia({
        video: {
          mediaSource: "screen"
        }
      })
      .then(stream => {
        const track = stream.getVideoTracks()[0];
        const imageCapture = new ImageCapture(track);
        
        return imageCapture.grabFrame()
          .then(bitmap => {
            track.stop();
            
            const canvas = document.createElement('canvas');
            canvas.width = bitmap.width;
            canvas.height = bitmap.height;
            
            const ctx = canvas.getContext('2d');
            ctx.drawImage(bitmap, 0, 0);
            
            resolve(canvas.toDataURL('image/png'));
          })
          .catch(err => {
            console.error("grabFrame failed:", err);
            track.stop();
            resolve(null);
          });
      })
      .catch(err => {
        console.error("getDisplayMedia failed:", err);
        resolve(null);
      });
    } else {
      console.log("Screen Capture API not available");
      resolve(null);
    }
  });
}

function addManualScreenshotButton() {
  // Only add the button if it doesn't exist
  if (!document.getElementById('manual-screenshot-button')) {
    const button = document.createElement('button');
    button.id = 'manual-screenshot-button';
    button.className = 'control-button';
    button.style.position = 'absolute';
    button.style.top = '70px';
    button.style.left = '20px';
    button.style.zIndex = '100';
    button.style.backgroundColor = '#10B981'; // Green
    button.innerHTML = `
      <svg class="button-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"></path>
        <circle cx="12" cy="13" r="4"></circle>
      </svg>
      Take Screenshot
    `;
    
    button.addEventListener('click', async function() {
      // Show capturing feedback
      button.innerHTML = `
        <svg class="button-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <circle cx="12" cy="12" r="10"></circle>
          <polyline points="12 6 12 12 16 14"></polyline>
        </svg>
        Capturing...
      `;
      button.style.backgroundColor = '#3B82F6'; // Blue
      
      // Slight delay to show the feedback
      setTimeout(async () => {
        // Try to take the screenshot
        const result = await takeScreenshot();
        
        // If direct capture failed, use the parameter visualization
        if (!result) {
          const visualScreenshot = createSimulationVisual();
          screenshotCount++;
          const id = `screenshot_${new Date().toISOString().replace(/[:.]/g, '')}_${screenshotCount}`;
          await saveScreenshot(visualScreenshot, id);
          console.log(`Fallback screenshot ${screenshotCount} saved`);
          updateScreenshotStatus();
        }
        
        // Reset button
        button.innerHTML = `
          <svg class="button-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"></path>
            <circle cx="12" cy="13" r="4"></circle>
          </svg>
          Take Screenshot
        `;
        button.style.backgroundColor = '#10B981'; // Back to green
      }, 300);
    });
    
    document.body.appendChild(button);
  }
}


function loadHTML2Canvas() {
  return new Promise((resolve, reject) => {
    if (window.html2canvas) {
      resolve();
      return;
    }
    
    console.log("Loading html2canvas library...");
    const script = document.createElement('script');
    script.src = "https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js";
    script.onload = () => {
      console.log("html2canvas loaded successfully");
      resolve();
    };
    script.onerror = (err) => {
      console.error("Failed to load html2canvas:", err);
      reject(err);
    };
    document.head.appendChild(script);
  });
}

// Create and download a zip file with all screenshots
async function createAndDownloadZip() {
  try {
    // Get all screenshots from IndexedDB
    const screenshots = await getAllScreenshots();
    
    if (screenshots.length === 0) {
      console.warn("No screenshots to download");
      alert("No screenshots available to download");
      return;
    }
    
    // Create a new JSZip instance
    const zip = new JSZip();
    
    // Add each screenshot to the zip
    screenshots.forEach(screenshot => {
      // Convert data URL to blob
      const imageData = screenshot.data.split(',')[1];
      const byteCharacters = atob(imageData);
      const byteNumbers = new Array(byteCharacters.length);
      
      for (let i = 0; i < byteCharacters.length; i++) {
        byteNumbers[i] = byteCharacters.charCodeAt(i);
      }
      
      const byteArray = new Uint8Array(byteNumbers);
      const blob = new Blob([byteArray], { type: 'image/png' });
      
      // Add to zip
      zip.file(`${screenshot.id}.png`, blob);
    });
    
    // Generate the zip file
    const zipBlob = await zip.generateAsync({ type: 'blob' });
    
    // Download the zip using FileSaver.js
    saveAs(zipBlob, `4d-simulator-screenshots-${new Date().toISOString().slice(0, 10)}.zip`);
    
    console.log(`Downloaded ${screenshots.length} screenshots as zip`);
  } catch (error) {
    console.error('Error creating zip file:', error);
    alert("Error preparing screenshots for download. See console for details.");
  }
}

    </script>
  </body>
</html>